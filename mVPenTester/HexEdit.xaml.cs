using Iced.Intel;
using ICSharpCode.SharpZipLib.Zip.Compression.Streams;
using Microsoft.Win32;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IdentityModel.Tokens.Jwt;
using System.IO;
using System.IO.Compression;
using System.Text;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Input;
using System.Windows.Media;

namespace mVPenTester
{
    /// <summary>
    /// Interaction logic for HexEdit.xaml
    /// </summary>
    public partial class HexEdit : Window
    {
        public string CURRENT_FILE;
        public bool isHexDumped;
        public bool isSkipped;

        #region COMPRESSION_TYPE & SEPERATE BUFFER
        public bool isZlib;
        public List<byte> sepBuff;
        #endregion
        #region ENCODER/DECODER
        public enum ENCODE_DECODE {
            base64, aes,
            jwt, rc2, hexdump, urlencode
        }
        #endregion
        #region MEMORY EDITOR
        ProcessList memEditor;
        MemorySearch memorySearcher;
        List<object> previousVal;
        public struct AdrScan {
            public object address1 { get; set; }
            public object value1 { get; set; }
            public object previous1 { get; set; }
            public object MEM_VAL { get; set; }
        }
        //Process ID for Memory Editor
        int _proc_ID;
        #endregion
        public HexEdit() {
            InitializeComponent();
            this.MaxHeight = SystemParameters.MaximizedPrimaryScreenHeight;
        }
        private void Button_Click(object sender, RoutedEventArgs e) {
            Close();
        }
        private void Window_Loaded(object sender, RoutedEventArgs e)
        {
            isHexDumped = false;
            isSkipped = false;
            CURRENT_FILE = null;

            #region COMPRESSION TYPES
            isZlib = false;
            #endregion
            sepBuff = new List<byte>();
            IsSkippedRender();

            //List all the processes to the tree
            memEditor = new ProcessList(runningProcs, runningApps);

            //Search for a memory address
            memorySearcher = new MemorySearch();

            //Previous vals
            previousVal = new List<object>();

            //Get the process
            //Process test = Process.GetProcessesByName("notepad")[0];
            ////Open the process via ID
            //memorySearcher.openProcess(test.Id);

            //Get this value from memory
            //byte[] scanVal = BitConverter.GetBytes(54);

            //memorySearcher.firstScan(scanVal,new Action(()=> {
            //    foreach (SearchResult sr in memorySearcher.Results) {
            //        addressFound.Items.Add(new AdrScan() {
            //        address1 = sr.Address.ToString("X8"),
            //        value1 = BitConverter.ToInt32(sr.Buffer,0).ToString(),
            //        MEM_VAL = sr
            //    });
            //    }
            //}));
        }

        private void Grid_MouseDown(object sender, MouseButtonEventArgs e)
        {
            if (e.ChangedButton == MouseButton.Left)
                DragMove();
        }
        private void MenuItem_Click(object sender, RoutedEventArgs e)
        {
            OpenFileDialog openFile = new OpenFileDialog();
            bool? result = openFile.ShowDialog();
            string fileContents = null;
            if (result == true)
            {
                CURRENT_FILE = openFile.FileName;
                fileContents = File.ReadAllText(openFile.FileName);
                hexEditor.FileName = openFile.FileName;
            }
            disAssemb.Clear();
            if (fileContents != null)
            {
                ulong exampleCodeRip = 0x00007FFAC46ACDA4;
                byte[] bytes = hexEditor.GetAllBytes(); //Encoding.ASCII.GetBytes(fileContents);

                var codeReader = new ByteArrayCodeReader(bytes);
                var decoder = Iced.Intel.Decoder.Create(64, codeReader);
                decoder.IP = exampleCodeRip;
                ulong endRip = decoder.IP + (uint)bytes.Length;

                List<Instruction> instructions = new List<Instruction>();
                while (decoder.IP < endRip)
                    instructions.Add(decoder.Decode());

                var formatter = new NasmFormatter();
                formatter.Options.DigitSeparator = "`";
                formatter.Options.FirstOperandCharIndex = 10;
                var output = new StringOutput();
                foreach (var instr in instructions)
                {
                    formatter.Format(instr, output);
                    disAssemb.AppendText(instr.IP.ToString("X16"));
                    disAssemb.AppendText(" ");
                    int instrLen = instr.Length;
                    int byteBaseIndex = (int)(instr.IP - exampleCodeRip);
                    for (int i = 0; i < instrLen; i++)
                        disAssemb.AppendText(bytes[byteBaseIndex + i].ToString("X2"));
                    int missingBytes = 10 - instrLen;
                    for (int i = 0; i < missingBytes; i++)
                        disAssemb.AppendText(" ");
                    disAssemb.AppendText(" ");
                    disAssemb.AppendText($"{output.ToStringAndReset()} {Environment.NewLine}");
                    //disAssemb.AppendText(output.ToStringAndReset());
                }
            }
        }
        private void MenuItem_Click_1(object sender, RoutedEventArgs e)
        {
            if (CURRENT_FILE != null)
                hexEditor.SubmitChanges();
        }
        private void MenuItem_Click_2(object sender, RoutedEventArgs e)
        {
            SaveFileDialog saveDialog = new SaveFileDialog()
            {
                Filter = "Text Files|*.txt|All Files|*.*"
            };
            if (saveDialog.ShowDialog() == true)
                hexEditor.SubmitChanges(saveDialog.FileName);
        }
        private void MenuItem_Click_3(object sender, RoutedEventArgs e)
        {
            //hexTxBox.Text = base64Decode(hexTxBox.Text);
            try {
                hexTxBox.Foreground = Brushes.White;
                byte[] inp = Convert.FromBase64String(hexTxBox.Text);

                //skip=23
                if (isSkipped)
                    inp = GetSkipped(inp, Convert.ToInt32(skippedValue.Text) - 1);

                string outputRes = "";

                if (isZlib)
                {
                    Stream stream = Decompress(inp);
                    using (StreamReader streamReader = new StreamReader(stream, Encoding.UTF8))
                    {
                        outputRes = streamReader.ReadToEnd();
                    }
                }
                else {
                    outputRes = isHexDumped ? ByteArrayToString(inp)
                        : Encoding.UTF8.GetString(inp);
                }
                hexTxBox.Text = outputRes;

                //Check if hex dumped
                //string decodedString = isHexDumped ? ByteArrayToString(data)
                //     : Encoding.UTF8.GetString(data);
                //hexTxBox.Text = decodedString;
            }
            catch (Exception ex) {
                hexTxBox.Foreground = Brushes.Red;
                hexTxBox.Text = ex.Message;
            }
        }
        private void MenuItem_Click_4(object sender, RoutedEventArgs e)
        {
            //Hex Dump
            isHexDumped = !isHexDumped;
            hxdump.IsChecked = isHexDumped;
            hDUMP.IsChecked = isHexDumped;
        }
        private void CheckBox_Click(object sender, RoutedEventArgs e)
        {
            isHexDumped = !isHexDumped;
            hxdump.IsChecked = isHexDumped;
            hDUMP.IsChecked = isHexDumped;
        }
        public static string ByteArrayToString(byte[] ba)
        {
            StringBuilder hex = new StringBuilder(ba.Length * 2);
            foreach (byte b in ba)
                hex.AppendFormat("{0:X2} ", b);
            return hex.ToString();
        }
        public byte[] GetSkipped(byte[] ba, int index)
        {
            List<byte> vs = new List<byte>();
            int i = 0;
            foreach (byte b in ba) {
                if (i > index)
                    vs.Add(b);
                else
                    sepBuff.Add(b);
                i++;
            }
            byte[] newByteArr = new byte[vs.Count];
            for (int j = 0; j < newByteArr.Length; j++)
                newByteArr[j] = vs[j];
            
            return newByteArr;
        }
        public static Stream Decompress(byte[] data) {
            var outputStream = new MemoryStream();
            using (var compressedStream = new MemoryStream(data))
            using (var inputStream = new InflaterInputStream(compressedStream))
            {
                inputStream.CopyTo(outputStream);
                outputStream.Position = 0;
                return outputStream;
            }
        }
        private void MenuItem_Click_5(object sender, RoutedEventArgs e)
        {
            var handler = new JwtSecurityTokenHandler();
            var decode = handler.ReadJwtToken(hexTxBox.Text);
            if (isHexDumped) {
                byte[] bytes = Encoding.ASCII.GetBytes(decode.ToString());
                hexTxBox.Text = ByteArrayToString(bytes);
            }
            else
                hexTxBox.Text = decode.ToString();
        }
        private void MenuItem_Click_6(object sender, RoutedEventArgs e)
        {
            //Open
            OpenFileDialog openFile = new OpenFileDialog();
            if (openFile.ShowDialog() == true)
                hexTxBox.Text = File.ReadAllText(openFile.FileName);
        }
        private void MenuItem_Click_7(object sender, RoutedEventArgs e)
        {
            //Save
            SaveFileDialog saveDialog = new SaveFileDialog();
            if (saveDialog.ShowDialog() == true)
                File.WriteAllText(saveDialog.FileName, hexTxBox.Text);
        }
        private void MenuItem_Click_8(object sender, RoutedEventArgs e)
        {
            isSkipped = !isSkipped;
            IsSkippedRender();
        }
        private void MenuItem_Click_9(object sender, RoutedEventArgs e)
        {
            isZlib = !isZlib;
            zlibCheck.IsChecked = isZlib;
        }
        private void CheckBox_Click_1(object sender, RoutedEventArgs e)
        {
            isZlib = !isZlib;
            zlibMenu.IsChecked = isZlib;
        }
        private void MenuItem_Click_10(object sender, RoutedEventArgs e)
        {
            var compress = new Func<byte[], byte[]>(a => {
                using (var ms = new System.IO.MemoryStream())
                {
                    using (var compressor =
                           new Ionic.Zlib.ZlibStream(ms,
                                                      Ionic.Zlib.CompressionMode.Compress,
                                                      Ionic.Zlib.CompressionLevel.BestCompression))
                    {
                        compressor.Write(a, 0, a.Length);
                    }
                    return ms.ToArray();
                }
            });
            byte[] Compressed = compress(Encoding.ASCII.GetBytes(hexTxBox.Text));
            byte[] constantData = new byte[sepBuff.Count];
            for (int i = 0; i < sepBuff.Count; i++)
                constantData[i] = sepBuff[i];

            //Fix this later
            List<byte> byteRES = new List<byte>();
            foreach (byte b in constantData)
                byteRES.Add(b);
            foreach (byte b in Compressed)
                byteRES.Add(b);

            byte[] result = new byte[byteRES.Count];
            for (int i = 0; i < byteRES.Count; i++)
                result[i] = byteRES[i];

            hexTxBox.Text = Convert.ToBase64String(result); //ByteArrayToString(result);
        }
        void IsSkippedRender()
        {
            skippedTextBlock.Foreground = isSkipped ? Brushes.White : Brushes.Gray;
            skippedValue.IsReadOnly = !isSkipped;
        }
        //Gzip compressor and decompressor of a buffer
        private static byte[] CompressionGZIP(byte[] data, CompressionMode cmp)
        {
            using (var compressedStream = new MemoryStream())
            using (var zipStream = new GZipStream(compressedStream, 
                cmp))//CompressionMode.Compress))
            {
                zipStream.Write(data, 0, data.Length);
                zipStream.Close();
                return compressedStream.ToArray();
            }
        }
        private void ListViewItem_PreviewMouseDown(object sender, MouseButtonEventArgs e)
        {
            Grid grid = new Grid();
            ComboBox box = new ComboBox() {
                Height = 20,
                Width = 120, Background = Brushes.Gray
            };
            box.Items.Add("Encode");
            box.Items.Add("Decode");
            TextBlock tx = new TextBlock() {
                Foreground = Brushes.White,
                FontFamily = new FontFamily("Consolas"),
                FontSize = 20, Text = "BASE64", Margin = new Thickness(240,0,0,0)
            };

            grid.Children.Add(box);
            grid.Children.Add(tx);
            ListViewItem list = new ListViewItem() { Height = 80,
                FontFamily = new FontFamily("Consolas"), Foreground = Brushes.White,
                Background = Brushes.Black, Content = grid, BorderBrush = Brushes.Gray,
                Tag = ENCODE_DECODE.base64
            };
            decodeEncode.Items.Add(list);
        }
        private void getResultBtn_Click(object sender, RoutedEventArgs e) {
            string cookingResult = entryText.Text;
            foreach (ListViewItem li in decodeEncode.Items) {
                if ((ENCODE_DECODE)li.Tag == ENCODE_DECODE.base64) {
                    bool? typeED = null;
                    foreach (object bb in ((Grid)li.Content).Children){
                        if (bb is ComboBox) {
                            int selectedInd = ((ComboBox)bb).SelectedIndex;
                            switch (selectedInd) {
                                case 0:
                                    typeED = true;
                                    break;
                                case 1:
                                    typeED = false;
                                    break;
                                default:
                                    typeED = false;
                                    break;
                            }
                        }
                    }
                    cookingResult = typeED == true ?
                        Convert.ToBase64String(Encoding.UTF8.GetBytes(cookingResult)):
                        Encoding.UTF8.GetString(Convert.FromBase64String(cookingResult));
                }
            }
            outputText.Text = cookingResult;
        }
        private void clearBtn_Click(object sender, RoutedEventArgs e) {
            decodeEncode.Items.Clear();
        }
        private void jwtED_PreviewMouseDown(object sender, MouseButtonEventArgs e){
            (new EncodeDecodeEntry(ENCODE_DECODE.jwt)).AddNewItem("JWT", decodeEncode);
        }
        private void hexDumpED_PreviewMouseDown(object sender, MouseButtonEventArgs e){
            (new EncodeDecodeEntry(ENCODE_DECODE.hexdump)).AddNewItem("HEX DUMP", decodeEncode);
        }
        #region MEM EDITOR EVENT HANDLERS
        private void firstScan_Click(object sender, RoutedEventArgs e) {
            if (_proc_ID != null && !string.IsNullOrEmpty(ScanValue.Text)) {
                //Get the process and open the process via ID
                memorySearcher.openProcess(_proc_ID);

                //Get this value from memory
                byte[] scanVal = BitConverter.GetBytes(Convert.ToInt32(ScanValue.Text));

                memorySearcher.firstScan(scanVal, new Action(() => {
                    addressFound.Items.Clear();
                    previousVal.Clear();
                    foreach (SearchResult sr in memorySearcher.Results) {
                        addressFound.Items.Add(new AdrScan() {
                            address1 = sr.Address.ToString("X8"),
                            value1 = BitConverter.ToInt32(sr.Buffer, 0).ToString(),
                            MEM_VAL = sr
                        });
                        previousVal.Add(BitConverter.ToInt32(sr.Buffer, 0).ToString());
                    }
                }));
            } else {
                MessageBox.Show("Please select a process!");
            }
        }
        private void runningProcs_Selected(object sender, RoutedEventArgs e) {
            TreeViewItem tvi = e.OriginalSource as TreeViewItem;
            _proc_ID = int.Parse(tvi.Tag.ToString());
            selectedProg.Text = $"Selected Program: {tvi.Header}";
        }
        private void nextScan_Click(object sender, RoutedEventArgs e) {
            if (_proc_ID != null && !string.IsNullOrEmpty(ScanValue.Text)) {
                addressFound.Items.Clear();

                byte[] scanVal = BitConverter.GetBytes(Convert.ToInt32(ScanValue.Text));

                memorySearcher.nextScan(scanVal, new Action(() => {
                    for (int i = 0; i < memorySearcher.Results.Length; i++) {
                        SearchResult sr = memorySearcher.Results[i];
                        addressFound.Items.Add(new AdrScan()
                        {
                            address1 = sr.Address.ToString("X8"),
                            value1 = BitConverter.ToInt32(sr.Buffer, 0).ToString(),
                            previous1 = previousVal[i]
                        });
                    }
                }));
            }
        }
        private void runningApps_Selected(object sender, RoutedEventArgs e) {
            TreeViewItem tvi = e.OriginalSource as TreeViewItem;
            _proc_ID = int.Parse(tvi.Tag.ToString());
            selectedProg.Text = $"Selected Program: {tvi.Header}";
        }
        private void addressListed_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            address_listed s = (address_listed)addressListed.Items.GetItemAt(addressListed.SelectedIndex);
            memorySearcher.writeMemory((IntPtr)Convert.ToInt32(s.address2, 16),new byte[] {0x14});
            byte[] cool = memorySearcher.readMemory((IntPtr)Convert.ToInt32(s.address2, 16), 4);
            MessageBox.Show(BitConverter.ToInt32(cool,0).ToString());
            //MessageBox.Show(s.ToString());
        }
        private void addressFound_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            AdrScan s = (AdrScan)addressFound.Items.GetItemAt(addressFound.SelectedIndex);
            addressListed.Items.Add(new address_listed() {
                isActive = false,
                Description = "",
                address2 = s.address1.ToString(),
                value2 = s.value1.ToString()
            });
        }
        private struct address_listed {
            public bool isActive { get; set; }
            public string Description { get; set; }
            public string address2 { get; set; }
            public string type2 { get; set; }
            public string value2 { get; set; }
        }
        #endregion

    }
}
