using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Shapes;
using System.Windows.Threading;

namespace mVPenTester
{
    /// <summary>
    /// Interaction logic for Bruteforce.xaml
    /// </summary>
    public partial class Bruteforce : Window
    {
        TextBoxMessage txmsg;
        private enum BRUTE_URL
        {
            DIRECTORY,
            SUBDOMAIN
        };
        BRUTE_URL brute_url;
        public Bruteforce()
        {
            InitializeComponent();
            this.MaxHeight = SystemParameters.MaximizedPrimaryScreenHeight;
            txmsg = new TextBoxMessage(bruteConsole);

            //Init brute force option for URLs
            brute_url = BRUTE_URL.DIRECTORY;
        }
        private void Button_Click(object sender, RoutedEventArgs e)
        {
            Close();
        }
        private void Grid_MouseDown(object sender, MouseButtonEventArgs e)
        {
            if (e.ChangedButton == MouseButton.Left)
                DragMove();
            maximumMin.Content = (WindowState == WindowState.Normal) ? "🗖" : "⧉";
        }
        private void maximumMin_Click(object sender, RoutedEventArgs e)
        {
            WindowState = (WindowState == WindowState.Normal) ? WindowState = WindowState.Maximized : WindowState = WindowState.Normal;
            maximumMin.Content = (WindowState == WindowState.Normal) ? "🗖" : "⧉";
        }
        private void Window_SizeChanged(object sender, SizeChangedEventArgs e)
        {
            this.BorderThickness = (WindowState == WindowState.Maximized) ? this.BorderThickness = new System.Windows.Thickness(6)
               : this.BorderThickness = new System.Windows.Thickness(0);
            maximumMin.Content = (WindowState == WindowState.Normal) ? "🗖" : "⧉";
        }
        private async Task BruteThread(string url, string[] wordlist, List<string> listing,
            BRUTE_URL url_b) {
            if (url_b == BRUTE_URL.DIRECTORY) {
                foreach (string q in wordlist)
                    await CheckUrl(url + q, url, q, listing);
            }
            else if (url_b == BRUTE_URL.SUBDOMAIN) {
                foreach (string q in wordlist)
                    await CheckUrl($"https://{q.Replace("\r",String.Empty)}.{url}", url, q, listing);
            }
        }
        private async Task<string> CheckUrl(string url, string q1, string q2, List<string> sucessfulQueries)
        {
            bool exists = false;
            var request = HttpWebRequest.Create(url);
            request.Timeout = 1000;
            request.Method = WebRequestMethods.Http.Head;
            string printFormat = brute_url == BRUTE_URL.DIRECTORY ? q1 + q2 : 
                q2.Replace("\r",String.Empty) + "." + q1;
            try {
                using (var response = await request.GetResponseAsync() as HttpWebResponse)
                {
                    if (response.StatusCode == HttpStatusCode.OK) exists = true;
                    bruteResult.Text += "[+] Found:  " + printFormat + Environment.NewLine;
                    //Add the successful queries to list
                    sucessfulQueries.Add(printFormat);
                    return (response.StatusCode.ToString());
                }
            }
            catch {
                string a = "a";
                bruteResult.Text += "[-] Not found:  " + printFormat + Environment.NewLine;
                return (a);
            }
        }

        private void runProc_Click(object sender, RoutedEventArgs e) {

        }

        private void subdomainOption_Checked(object sender, RoutedEventArgs e) {
            if (!subdomainOption.IsChecked) {
                subdomainOption.IsChecked = true;
                directoryOption.IsChecked = false;
                brute_url = BRUTE_URL.SUBDOMAIN;
            }
        }

        private void directoryOption_Checked(object sender, RoutedEventArgs e) {
            if (!directoryOption.IsChecked) {
                directoryOption.IsChecked = true;
                subdomainOption.IsChecked = false;
                brute_url = BRUTE_URL.DIRECTORY;
            }
        }

        private async void Button_Click_1(object sender, RoutedEventArgs e)
        {
            bruteResult.Clear();
            string url = urlText.Text;
            string[] charSplit = bruteList.Text.Split('\n');
            //List of tasks
            List<Task> tasks = new List<Task>();
            //Find successful queries
            List<string> successes = new List<string>();
            if (string.IsNullOrWhiteSpace(url))
                bruteResult.Text = "Error: There was no specified URL. Try entering a URL host to target...";
            else {
                try {
                    if (charSplit.Length >= 10) {
                        //Split the array into certain tasks
                        int splitInto = !string.IsNullOrWhiteSpace(splitIntoTxt.Text) ? Convert.ToInt32(splitIntoTxt.Text)
                            : charSplit.Length;

                        //The splitted arrays
                        int j = 0;
                        string[][] splitted = charSplit.GroupBy(s => j++ / splitInto).Select(s =>
                           s.ToArray()).ToArray();

                        //Add each of the tasks
                        for (int i = 0; i < splitted.Length; i++) {
                            tasks.Add(BruteThread(url, splitted[i],successes, brute_url));
                        }

                        //Print the message
                        SendTXTBoxMsg($"Starting bruteforce search...\r\n" +
                            $"== Info ==\r\n" +
                            $"\tSplit into arrays of: {splitInto}\r\n" +
                            $"\tThreads: {tasks.Count}\r\n" +
                            $"\tQueries: {charSplit.Length}");

                        //Wait for all multithreaded tasks
                        await Task.WhenAll(tasks.ToArray());

                        if (successes.Count > 0)
                        {
                            StringBuilder sb = new StringBuilder();
                            for (int i = 0; i < successes.Count; i++)
                                sb.AppendLine(successes[i]);

                            SendTXTBoxMsg($"Search complete...\n== Found {successes.Count} results ==\n" +
                                $"{sb}");
                        }
                        else
                            SendTXTBoxMsg("Search complete... There were no successful results");
                    }
                    else
                        bruteResult.Text += "Please add more queries within the wordlists (10 or more queries)";
                }
                catch { }
            }
        }

        private async Task<string> GetWordlist(string url) {
            HttpWebRequest request = WebRequest.Create(new Uri(url)) as HttpWebRequest;
            request.Method = "GET";
            request.Accept = "application/json";
            WebResponse responseObject = await Task<WebResponse>.Factory.FromAsync(request.BeginGetResponse, request.EndGetResponse, request);
            var responseStream = responseObject.GetResponseStream();
            var sr = new StreamReader(responseStream);
            string wordListEntires = await sr.ReadToEndAsync();

            return wordListEntires;
        }

        private async void commondirb_Click(object sender, RoutedEventArgs e) {
            SendTXTBoxMsg("Retrieving wordlist (dirb/common.txt) please wait...");
            string setWordlist = await GetWordlist("https://raw.githubusercontent.com/v0re/dirb/master/wordlists/common.txt");
            if (setWordlist != string.Empty) {
                await Task.Run(() => Dispatcher.Invoke(() => bruteList.Text = setWordlist));
                SendTXTBoxMsg("Successfully set the wordlist (common.txt from dirb repository)...");
            }
            else
                SendTXTBoxMsg("ERROR: There was an error with obtaining the wordlist from that request");
        }

        //Check the Directory bruteforce option

        private void bruteConsole_KeyDown(object sender, KeyEventArgs e)
        {
            string[] lines = bruteConsole.Text.Split('\n');
            string lastLine = lines[lines.Length - 1];
            string[] command = lastLine.Split('>');
            try
            {
                string[] args = command[1].Split(' ');
                if (e.Key == Key.Enter)
                {
                    try
                    {
                        if (string.IsNullOrWhiteSpace(command[1]))
                            txmsg.EmptyEntry();
                        else
                        {
                            if (args.Length <= 2)
                            {
                                switch (command[1].ToLower())
                                {
                                    case " help":
                                        StringBuilder sb = new StringBuilder();
                                        sb.AppendLine("=== List of commands ===");
                                        sb.AppendLine("\t-help - shows list of commands");
                                        sb.AppendLine("\t-clear - clears console");
                                        sb.AppendLine("\t-url [--set/-s] [url] - set the url for directory bruteforce");
                                        SendTXTBoxMsg(sb.ToString());
                                        break;
                                    case " clear":
                                        bruteConsole.Text = "> ";
                                        bruteConsole.SelectionStart = bruteConsole.Text.Length;
                                        bruteConsole.SelectionLength = 0;
                                        break;
                                    default:
                                        SendTXTBoxMsg("ERROR: Error with parsing command...");
                                        break;
                                }
                            }
                            else
                            {
                                if (command[1].ToLower().StartsWith(" url") == true)
                                {
                                    if (args[2] == "--set" || args[2] == "-s")
                                    {
                                        urlText.Text = args[3];
                                        urlHttp.Text = args[3];
                                        SendTXTBoxMsg($"Success! URL set to {args[3]}");
                                    }
                                }
                            }
                        }
                    }
                    catch (Exception ex) {
                        SendTXTBoxMsg(ex.Message);
                    }
                }
            }
            catch (Exception ex) {
                SendTXTBoxMsg(ex.Message);
            }
        }
        public void SendTXTBoxMsg(string msg)
        {
            bruteConsole.Text = bruteConsole.Text + Environment.NewLine;
            bruteConsole.Text += "\r" + msg + "\r\n" + Environment.NewLine;
            bruteConsole.Text += "> ";
            bruteConsole.SelectionStart = bruteConsole.Text.Length;
            bruteConsole.SelectionLength = 0;
            bruteConsole.ScrollToEnd();
        }
        private async void Button_Click_2(object sender, RoutedEventArgs e)
        {
            outputHTTP.Clear();
            string[] listOfQueries = wordlistTxt_http.Text.Split('\n');
            HttpClient client = new HttpClient();
            try {
                string[] pms = id_params.Text.Split('\n');
                for (int i = 0; i < pms.Length; i++) {
                    for (int j = 0; j < listOfQueries.Length; j++) {
                        var values = new Dictionary<string, string>();
                        values.Add(pms[i], listOfQueries[j]);
                        var content = new FormUrlEncodedContent(values);
                        var response = await client.PostAsync(urlHttp.Text, content);
                        byte[] httpStream = await response.Content.ReadAsByteArrayAsync();
                        string contentRespons = await response.Content.ReadAsStringAsync();
                        outputHTTP.AppendText(contentRespons + "\n");
                        outputHTTP.ScrollToEnd();
                        httpListView.Items.Add(new HTTPRECORD()
                        {
                            request = pms[i],
                            payload1 = listOfQueries[j],
                            length = httpStream.Length,
                            status = response.StatusCode.ToString(),
                            response = contentRespons
                        });
                    }
                }
            }
            catch (Exception ex) {
                outputHTTP.Text = ex.Message;
            }
        }
        private void ResizeHeaders() {
            double aW = httpListView.ActualWidth;
            gr1.Width = aW / 5;
            gr2.Width = aW / 5;
            gr3.Width = aW / 5;
            gr4.Width = aW / 5;
            gr5.Width = aW / 5;
        }
        private void GridSplitter_DragCompleted(object sender, System.Windows.Controls.Primitives.DragCompletedEventArgs e) {
            ResizeHeaders();
        }
        private void bruteforceTABS_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            if (bruteforceTABS.SelectedIndex == 1) {
                Dispatcher.Invoke(new Action(() => {
                    ResizeHeaders();
                }), DispatcherPriority.Loaded);
            }
        }
        private void Button_Click_3(object sender, RoutedEventArgs e) {
            WindowState = WindowState.Minimized;
        }
    }
    public class HTTPRECORD
    {
        public string request { get; set; }
        public string payload1 { get; set; }
        public string status { get; set; }
        public int length { get; set; }
        public string response { get; set; }
    }
}
